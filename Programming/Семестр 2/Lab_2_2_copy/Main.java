// В ограниченный стек(максимум 10 значений) два потока помещают символы, 
// открывающих скобок трех типов (,{,[ какая именно опредкляется случайно. 
// Ещё три потока ароизводят символы закрывающих типов ),},] , 
// каждый из этих потоков производят скобки только одного типа. 
// Если закрывающая суобка совпадает с типом открывающей скобки на вершине стека например, 
// обе круглые или обе фигурные, то последняя удаляется с вершины стека. Каждый из потоков, 
// производящий скобки может подряд произвести и занести в стек от 1 до 3 скобок (определяется случайно). 
// Каждый из потоков, производящих закрывающие скобки, может произвести только 1 скобку. 
// Открывающая скобка не может быть помещена в стек, если стек полный. 
// Невозможно ничего извлечь из стека, если он пуст. 
// В процессе выполнения программы после каждого добавления в стек скобки или её извлечения 
// из него необходимо выводить на экран имя потока и скобку. 
// А в следующей строке отображать состояние стека (его заполненной части) 
// после добавления в стек скобки или её извлечения из него в порядке от вершины стека до его основания

public class Main {
    public static void main(String[] args) throws InterruptedException {
        Stack<Character> stack = new Stack<>(10); // создаем общий стек

        while (true) {
            // создаем потоки для добавления открывающих скобок
            Thread opening1 = new Thread(new Opening(stack, "Opening1"));
            Thread opening2 = new Thread(new Opening(stack, "Opening2"));

            // создаем потоки для добавления закрывающих скобок
            Thread closing1 = new Thread(new Closing(stack, "Closing1"));
            Thread closing2 = new Thread(new Closing(stack, "Closing2"));
            Thread closing3 = new Thread(new Closing(stack, "Closing3"));

            // ожидаем завершения потоков
            opening1.join();
            opening2.join();
            closing1.join();
            closing2.join();
            closing3.join();
        }
    }
}
